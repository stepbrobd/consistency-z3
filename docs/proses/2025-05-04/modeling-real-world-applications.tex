\section{Modeling Real-World Applications}

Beyond theoretical explorations, our framework also supports practical modeling
distributed applications that may rely on complex combinations of semantics.
Instead of checking at source code level tracing possible code paths like Noctua
\cite{ma2024noctua} with SMT solvers, our approach operates at
axiomatic logic and
optionally application level, allowing researchers and system designers to
encode nodes (representing intermediate API endpoints or storage systems
providing consistency semantics) and edges (representing interactions or data
flows) within their systems. Each node may require or provide specific
consistency guarantees, while edges capture the ordering/visibility constraints
and optional application specific logics between events across services.

The \texttt{composable} function operates over a directed multigraph
whose nodes and
edges represent services (nodes) and interactions (edges) in a distributed
system. Each node and edge can specify which consistency guarantees it needs or
provides in the form of constraints (e.g., monotonic reads, read-your-writes).

\begin{itemize}
  \item \textit{Nodes:} each node represents a logical component like
    services or storage
    systems, each node can:
    \begin{itemize}
      \item Issue operations (e.g., read or write to shared state)
      \item Require certain consistency properties (e.g., monotonic
        reads) for these
        operations
      \item Provide certain consistency guarantees to downstream consumers
    \end{itemize}
    In the current implementation, each node stores:
    \begin{itemize}
      \item \texttt{name}: a unique identifier
      \item \texttt{needs}: a set of constraints that must be
        satisfied to uphold the node's
        required semantics
      \item \texttt{provs}: a set of constraints that characterize
        what the node provides to other
        nodes
    \end{itemize}

  \item \textit{Edges:} edges represent interactions or data flows
    between nodes, capturing:
    \begin{itemize}
      \item Precedence constraints (e.g., write `a` must return
        before read `b` starts) % Note: Consider \texttt{} for a and
        % b if they represent variables/values
      \item Required or optional additional constraints representing
        custom operations or
        relations that must hold between the source and destination nodes
    \end{itemize}
\end{itemize}

The \texttt{composable} function attempts to find an assignment of
constraints that
makes the entire graph "composable". In other words, it seeks a model in which
all nodes' \texttt{needs} can be matched with some nodes'
\texttt{provs}, and all edges'
constraints are satisfied simultaneously. This corresponds to verifying if there
is a coherent assignment of semantics across the system's interactions. Users
may provide zero or more semantics to \texttt{needs} and
\texttt{provs} for each node, and
similarly, zero or more constraints for each edge. During the check at each
level of the graph traversal, a \textit{pairwise} check between
source node \texttt{needs} in
conjunction of edge constraints against destination node
\texttt{provs} is performed.
If the pairwise check is successful, all previous assignments are recorded and
used as context for further checks. In case of pairwise check failure
(contradiction), the function backtracks and selects other possible assignments
if there are more than one provide in each of the source
\texttt{needs}, edge constraints, and destination \texttt{provs}.

% TODO: do we need pseudocode here?

\textit{Implementation:} given a starting node (conceptually, usually
a client) and a
set of premise constraints, the function begins a DFS through the graph. At each
node:
\begin{itemize}
  \item The function examines outgoing edges and their associated constraints.
  \item Each edge can impose conditions on the relationship between
    the source node's
    requirements (\texttt{needs}), the destination node's provided
    guarantees (\texttt{provs}),
    and any additional edge-specific constraints.
  \item The solver checks whether combining these constraints with
    the accumulated
    premise remains satisfiable.
\end{itemize}
If no consistent assignment is found for outgoing edges, the function
backtracks, exploring alternative paths or constraint combinations. During
traversal, the function uses the \texttt{compatible} checks behind
the scenes. For each
candidate combination of node-level and edge-level constraints, it
calls \texttt{compatible} to
ensure that no contradictions arise. If the DFS manages to visit all edges and
find consistent assignments for all node needs and provided constraints, the
function returns a \texttt{True} value along with a subgraph
(\texttt{result}) that records a
satisfying assignment. The returned subgraph shows which edges and nodes were
selected and how their constraints were matched. If no satisfying assignment is
found, the function returns \texttt{False}, and \texttt{None} for the graph.

\subsection{Example: Online Shopping}

Consider an online shop scenario where multiple services and components interact
to process customer interactions and purchases. The shop maintains an inventory
of products, and a shopping cart service, a transaction log to record purchases,
and the the client itself. Additionally, an arbitrator node to coordinate
interactions between the interactions between clients and the entire service
stack.

A customer uses a shopping cart service to preserve the state of the items they
intend to buy. The customer can read or write the cart's contents, adjusting
their intended purchases as they browse products. Let's say in this example,
clients do not care to see their latest update to the cart being propagated to
other devices immediately, but the states will eventually converge.

The shop holds the canonical inventory state. Before finalizing a purchase, the
customer's requested items must be checked against the shop's current inventory.
If items are available, the transaction can proceed, if not, the request fails
due to insufficient stock.

Once the shop confirms inventory, it records the customer's purchase in the
transaction log, and replicated across multiple nodes for fault tolerance.

An arbitrator acts as a gatekeeper that serializes requests and interacts with
both the shop (update inventory) and the transaction log (bookkeeping). When the
customer decides to make a purchase, the arbitrator:
\begin{itemize}
  \item Receives requests from client and write to a intermediate
    location (capturing
    the customer's intent)
  \item Reads from the shop's inventory to verify item availability
  \item If available, writes back to the shop to decrement the
    inventory and write and
    replicate the transaction to the log
  \item If not available, reply back to the client with an error
\end{itemize}

The arbitrator or serialization point pattern is commonly used in other system
implementations like Paxos \cite{lamport2001paxos} to maintain a
consistent order of
events at critial locations, ensuring that purchase requests are applied to the
shop and recorded in the transaction log in a well-defined sequence.

\textit{Nodes:}
\begin{itemize}
  \item \textit{Arbitrator:} Provides linearizability
  \item \textit{Tx:} Provides linearizability
  \item \textit{Shop:} Provides RYW + MR, ensuring that once
    arbitrator updates inventory, all
    subsequent reads observe the writes
  \item \textit{Client and Cart:} Represent endpoints that do not
    enforce any semantic by
    themselves but rely on the guarantees of the nodes they interact with
\end{itemize}

\textit{Edges:}
\begin{itemize}
  \item \texttt{Client} to \texttt{Cart} edge represent the customer
    adding items to their cart
  \item \texttt{Client} to \texttt{Shop} edge represent price checks
    or Browse inventory
  \item \texttt{Client} to \texttt{Arbitrator} edge represents a
    purchase request
  \item \texttt{Arbitrator} to \texttt{Shop} and \texttt{Arbitrator}
    to \texttt{Tx} edges represent the arbitrator's
    mediation: writing to the transaction log, reading and updating the shop's
    inventory state in sequential order
\end{itemize}

In this example, the \texttt{composable} function succeeds with a
graph containing one
of the possible satisfiable constraint assignments.

% TODO: rewrite with more detail like cross causal
\subsection{Example: Streaming Service}

Another example (simplified from DeathStarBench Media Service \cite{gan2019an}):
consider a streaming service with multiple components handling user
authentication, content delivery, and user interactions. The system comprises:

\begin{itemize}
  \item Admin: admin interface for content and user management operations
  \item Client: end-user interface for accessing streaming content and features
  \item Login: authentication service that acts like a user session manager
  \item User DB: user credential storage
  \item Metadata DB: content metadata storage
  \item Rent: rental transaction service
  \item Rent DB: transaction record storage
  \item Review: user review service
  \item Review DB: review storage
  \item Video: video streaming service for content delivery
  \item Video DB: video content storage providing
\end{itemize}

A user must first register and login through the authentication service before
accessing any content. The login service verifies credentials against the User
DB, which maintains consistent user states through Monotonic Writes and Writes
Follow Reads guarantees as updates performed by users needs to be reflected to
themselves right after.

When Browse content, the client interacts with the metadata services. Before
serving any content, users must first be authenticated through the login
service, then clients can issue read to metadata database to retrieve titles.
After selecting a media, clients can issue write to the Rent service to rent the
media for viewing. The Rent service must ensure that the title is available
through read to the metadata database. The Metadata DB provides Monotonic Reads
and Read Your Writes guarantees, allowing admin updates to be reflected visible
while tolerating some staleness for user reads.

Users can also write reviews for content they've watched. The review service
verifies content existence in Metadata DB. Writes the review to Review DB with
Read-Your-Writes ensuring users see their own reviews immediately while other
users may see slightly stale data.

Administrators use a separate interface to manage content and user access. When
uploading new content, the admin service updates metadata in Metadata DB,
uploads video content to Video DB. Both operations require prior admin
authentication (assuming admin users are pre-granted access). Video DB's Writes
Follow Reads guarantee ensures content version consistency.

As this example demonstrates, it's more complex than the online shopping mall
example. Listing of nodes and edges is not exhaustive, please see the actual
implementation for more details. The overall operational constraints are
captured through custom operation types with quantified constraints optionally
enforced at each node level.

% \subsection{Example: Antipode \cite{ferreira2023antipode}}
% TODO: rewrite after wrapping up
% Basic encodings of lineage and cross-service causal consistency (XCY) are
% finished but full implementation is still in progress. See
% \texttt{tests/test\_antipode.py} for
% details.

\subsection{Example: Cross Service Causal}

When reading the graph, think of it as a reversed tree (rooted from svc1) with
one branch growing from root to leaf (xc). The leaf node's (xc) prov/need field
in the implementation is set to \texttt{None} to indicate that it
does not provide any
guarantees, and will only be used for extraction (see descriptions below).
Implementation of \texttt{tests/test\_cross\_causal.py}:

\begin{verbatim}
            xc
           / <- mr + mw + ryw
        svc4 - wfr
       / <- mr + mw + wfr
     svc3 - ryw
    / <- mr + ryw + wfr
  svc2 - mw
 / <- mw + ryw + wfr
svc1 - mr
\end{verbatim}

This example demonstrates modeling a system where multiple services, each
offering only a basic consistency guarantee, are chained together. The goal is
to verify if their composition, mediated by specific inter-service constraints,
symbolic isolation, and the role of explicit ``glue'' constraints.

\textit{Setup}\footnote{I decided not to use the ``pseudo node'' in
the write up, it makes the explanation unnecessarily complex.}: We
model a linear chain of services: $\text{SVC1} \rightarrow
\text{SVC2} \rightarrow \text{SVC3} \rightarrow \text{SVC4}
\rightarrow \text{XC}$.
Each service $\text{SVC}n$ (for $n=1..4$) is designed to provide only
\textit{one} of the
four session guarantees via its \texttt{provs} attribute:
$\text{SVC}1$ provides MR, $\text{SVC}2$ provides
MW, $\text{SVC}3$ provides RYW, and $\text{SVC}4$ provides WFR.

\textit{Symbolic Isolation:} To prevent logical interference, the
guarantee provided by
each service (e.g., \texttt{MonotonicReads.assertions}) and the
constraints added on
the edges are instantiated using unique symbols specific to that service or edge
(e.g., using helpers like \texttt{gensym} and \texttt{assertion\_for}
from \texttt{tests/test\_cross\_causal.py}).
This ensures, for example, that the Monotonic Reads constraints of
$\text{SVC}1$ only
apply to operations symbolically designated as belonging to $\text{SVC}1$.

\textit{Composition via Edge Constraints:} The composition logic
resides in the ``glue''
constraints defined on the \texttt{cons} attribute of the edges connecting the
services. Since each service node only provides one session
guarantee, the edge $\text{SVC}n \rightarrow \text{SVC}(n+1)$ must
provide constraints representing the other three session guarantees needed to
potentially satisfy Causal Consistency up to that point.

The core idea of this example is to build a stronger guarantee by composing
weaker guarantees provided by individual services ($\text{SVC}1
\ldots 4$), using the
edges to supply the missing pieces. Verbatim:

\begin{itemize}
  \item $\text{SVC}1$ starts by providing only MR (via its
    \texttt{provs}, using symbols like $a_1, b_1, \ldots$).
    Its own \texttt{needs} are \texttt{None}.
  \item To potentially achieve Causal Consistency for operations
    passing from $\text{SVC}1$ to $\text{SVC}2$,
    the edge $\text{Edge}(\text{SVC1} \rightarrow \text{SVC2})$ must
    provide the other three required
    session guarantees: MW, RYW, and WFR (via its \texttt{cons},
    using unique symbols like $a_{12}, b_{12}, \ldots$).
    However, in real world implementations, edge constraints usually requires
    additional application specific logic to be satisfiable. In other word, edge
    constraints used in abstract representation implies the existence
    of application
    level protocols that enforces convergence of data either through
    consensus (like
    Raft \cite{diego2014raft} or Paxos \cite{lamport1998paxos}) or other means.
  \item When \texttt{composable} evaluates this step, it checks if
    the interaction is locally
    consistent based on the nodes' defined
    \texttt{provs}/\texttt{needs} and the edge's \texttt{cons}. If
    this local check passes (meaning $\text{SVC}2$'s required guarantee, Causal
      Consistency, is satisfied through what the edge + $\text{SVC}1$'s
    provs provide), we
    \textit{interpret} this (based on our setup) as achieving Causal
    Consistency for the
    combined path ($\text{SVC}1 + \text{Edge}(\text{SVC1} \rightarrow
    \text{SVC2})$) leading \textit{up to} $\text{SVC}2$.
  \item Now, although the path leading to $\text{SVC}2$ is causally
    consistent, $\text{SVC}2$ itself,
    according to its definition in this example, only
    \textit{provides} MW to the outside
    world (via its \texttt{provs}, using symbols $a_2, b_2, \ldots$).
  \item Therefore, for the \textit{next} service, $\text{SVC}3$, to
    maintain Causal Consistency
    relative to the operations flowing through the
    ($\text{SVC}1\rightarrow\text{SVC}2$) mesh, the edge
    $\text{Edge}(\text{SVC2} \rightarrow \text{SVC3})$ must
    supply the guarantees missing relative to $\text{SVC}2$'s
    provided MW. This means $\text{Edge}(\text{SVC2} \rightarrow
    \text{SVC3})$ must
    provide MR, RYW, and WFR (again, with unique symbols).
  \item This pattern repeats: each service node $\text{SVC}n$
    provides one specific
    guarantee, and the edge $\text{Edge}(n \rightarrow n+1)$ provides
    the complementary guarantees
    needed to ensure the cumulative path maintains the target property.
\end{itemize}

\textit{Symbol Equivalence:} For this composition to be meaningful, we must
conceptually link operations across services that refer to the same logical
action or data. For instance, if write $a_1$ in $\text{SVC}1$ and
write $a_2$ in $\text{SVC}2$ both
represent updates to the same user profile, ``glue'' constraints
equating relevant
aspects (like $a_1.\text{obj} = a_2.\text{obj}$ or $a_1.\text{ival} =
  a_2.\text{ival}$ despite their
different symbolic names) might be necessary. While the current test
code (\texttt{tests/test\_cross\_causal.py})
simplifies this by focusing on composing the consistency axioms, a more rigorous
model would include these explicit symbol equivalence constraints on the edges
(we are directly asserting symbols of $a_1$ are identical of those of $a_2$ for
simplicity).

\textit{Aggregation:} The \texttt{composable(g, svc1)} call attempts
to find a satisfying
assignment for the entire chain, respecting the \texttt{provs} of
each node and the \texttt{cons} of
each edge. If it returns \texttt{True}, it confirms that the
individual guarantees can
be composed under the specified edge constraints. Subsequently,
\texttt{extract(svc1, svc1, (ok, res))} can
synthesize a single logical formula representing the net end-to-end guarantee
achieved by the chain, starting from $\text{SVC}1$. This aggregated
constraint (\texttt{aggcons} in
the test code) could then be compared against a formal definition of Causal
Consistency.
